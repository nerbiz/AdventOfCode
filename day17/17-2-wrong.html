<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../FileReader.js';
            import Parser from './Parser.js';
            import Utilities from '../Utilities.js';

            const fileReader = new FileReader('./data.txt', new Parser());
            const target = await fileReader.parse();

            let solutions = [
                [23, -10], [25, -9], [27, -5], [29, -6], [22, -6], [21, -7], [9, 0], [27, -7], [24, -5], [25, -7], [26, -6], [25, -5], [6, 8], [11, -2], [20, -5], [29, -10], [6, 3], [28, -7], [8, 0], [30, -6], [29, -8], [20, -10], [6, 7], [6, 4], [6, 1], [14, -4], [21, -6], [26, -10], [7, -1], [7, 7], [8, -1], [21, -9], [6, 2], [20, -7], [30, -10], [14, -3], [20, -8], [13, -2], [7, 3], [28, -8], [29, -9], [15, -3], [22, -5], [26, -8], [25, -8], [25, -6], [15, -4], [9, -2], [15, -2], [12, -2], [28, -9], [12, -3], [24, -6], [23, -7], [25, -10], [7, 8], [11, -3], [26, -7], [7, 1], [23, -9], [6, 0], [22, -10], [27, -6], [8, 1], [22, -8], [13, -4], [7, 6], [28, -6], [11, -4], [12, -4], [26, -9], [7, 4], [24, -10], [23, -8], [30, -8], [7, 0], [9, -1], [10, -1], [26, -5], [22, -9], [6, 5], [7, 5], [23, -6], [28, -10], [10, -2], [11, -1], [20, -9], [14, -2], [29, -7], [13, -3], [23, -5], [24, -8], [27, -9], [30, -7], [28, -5], [21, -10], [7, 9], [6, 6], [21, -5], [27, -10], [7, 2], [30, -9], [21, -8], [22, -7], [24, -9], [20, -6], [6, 9], [29, -5], [8, -2], [27, -8], [30, -5], [24, -7]
            ];

            const possibilities = [];

            // Add the possibilities for reaching the target in 1 step
            // They are all the possible coordinates of the target
            for (let x = target.xMin; x <= target.xMax; x++) {
                for (let y = target.yMin; y <= target.yMax; y++) {
                    possibilities.push([x, y]);
                }
            }

            // Calculate the first X velocity that makes X >= xMin of the target,
            // in at least 2 steps, using triangular number formula
            let xMinVelocity = 0, endX;
            do {
                endX = ++xMinVelocity * (xMinVelocity + 1) / 2;
            } while (endX < target.xMin);

            // Calculate the other min/max velocities for at least 2 steps
            const xMaxVelocity = Math.floor(target.xMax / 2);
            const yMinVelocity = Math.floor(target.yMin / 2) + 1;
            const yMaxVelocity = Math.abs(target.yMin + 1);

            const xRange = Utilities.range(xMinVelocity, xMaxVelocity);
            const yRange = Utilities.range(yMinVelocity, yMaxVelocity);

            console.log(target);
            console.log('Min X velocity', xMinVelocity);
            console.log('Max X velocity', xMaxVelocity);
            console.log('Min Y velocity', yMinVelocity);
            console.log('Max Y velocity', yMaxVelocity);
            console.log('X range', xRange);
            console.log('Y range', yRange);

            console.groupCollapsed('Find X steps');

            const xValidSteps = xRange.map(x => {
                console.log('X', x);
                let sum = 0, steps = 0, decreaser = x + 1;
                const validSteps = [];

                while (sum <= target.xMax && --decreaser >= 0) {
                    sum += decreaser;
                    steps++;

                    // Target is reached, add the valid step amount
                    if (sum >= target.xMin && sum <= target.xMax) {
                        console.log('Add steps', steps, 'X is then', sum);
                        validSteps.push(decreaser === 0 ? Infinity : steps);
                    }
                }

                console.log('X', x, 'valid steps', validSteps);
                console.log('-'.repeat(30));

                return {x, validSteps};
            });

            console.groupEnd();
            console.groupCollapsed('Find Y steps');

            const yValidSteps = yRange.map(y => {
                console.log('Y', y);
                let sum = 0, steps, decreaser;
                // let xVelocities = [];
                const validSteps = [];

                // A positive Y goes back to zero after (y * 2) + 1 steps,
                // Y goes negative after that, so no need to check steps before that
                if (y > 0) {
                    steps = (y * 2) + 1;
                    decreaser = y * -1;
                } else {
                    steps = 0;
                    decreaser = y + 1;
                }

                while ((sum += --decreaser) >= target.yMin) {
                    steps++;

                    // Target is reached, couple with X velocities that match the step amount
                    if (sum >= target.yMin && sum <= target.yMax) {
                        console.log('Add steps', steps, 'Y is then', sum);
                        validSteps.push(steps);
                    }
                }

                // console.log('X velocities', Utilities.arrayUnique(xVelocities));
                console.log('Y', y, 'valid steps', validSteps);
                console.log('-'.repeat(30));

                return {y, validSteps};
            });

            console.groupEnd();

            console.log('Valid X steps', Utilities.clone(xValidSteps).map(steps => {
                steps.validSteps = steps.validSteps.join(', ');
                return steps;
            }));

            console.log('Valid Y steps', Utilities.clone(yValidSteps).map(steps => {
                steps.validSteps = steps.validSteps.join(', ');
                return steps;
            }));

            // Make X,Y pairs
            xValidSteps.forEach(xSteps => {
                const yCollection = [];
                console.log(xSteps);                

                // Check for Y velocities that reach the target in an equal amount of steps
                xSteps.validSteps.forEach(stepAmount => {
                    yValidSteps.filter(ySteps => ySteps.validSteps.includes(stepAmount))
                        .forEach(ySteps => yCollection.push(ySteps.y));
                });

                // Some X velocities result in the proper X position infitely
                // Check for Y velocities that take at least that amount of steps
                if (xSteps.validSteps.includes(Infinity)) {
                    const validSteps = xSteps.validSteps.filter(stepAmount => stepAmount !== Infinity);
                    const minimumSteps = Math.max(...validSteps);

                    const ySteps = yValidSteps
                        .filter(ySteps => ySteps.validSteps
                            .filter(stepAmount => stepAmount >= minimumSteps)
                            .length > 0)
                        .forEach(ySteps => yCollection.push(ySteps.y));
                }

                Utilities.arrayUnique(yCollection).forEach(y => possibilities.push([xSteps.x, y]))
            });





            console.log('Solutions', solutions
                // .sort((a, b) => a[0] - b[0]);
                .sort((a, b) => a[1] - b[1])
            );
            console.log('Possibilities', possibilities
                // .sort((a, b) => a[0] - b[0]);
                .sort((a, b) => a[1] - b[1])
            );
            let remaining = solutions.map(xy => xy.join(', '))
                .filter(xy => !possibilities.map(xy => xy.join(', ')).includes(xy))
                .map(xy => xy.split(', '))
                // .sort((a, b) => a[0] - b[0]);
                .sort((a, b) => a[1] - b[1]);
            console.log('Remaining', remaining);

            console.log(target);

            // 1103 is too low
            answer.innerText = possibilities.length;
        </script>
    </body>
</html>
