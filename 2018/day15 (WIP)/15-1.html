<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../../FileReader.js';
            import Parser from './Parser.js';
            import Array2d from '../../Array2d.js';
            import Pathfinding from '../../Pathfinding.js';
            import ArrayPrototype from '../../ArrayPrototype.js';

            ArrayPrototype.registerSortGrouped();
            ArrayPrototype.registerUnique();
            const fileReader = new FileReader('./datatest.txt', new Parser());
            const map = new Array2d(await fileReader.parse());
            const units = map.filter2d(location => ['E', 'G'].includes(location.value), true)
                .map(location => {
                    // Create a unit object and set the location in it
                    const unit = {
                        type: location.value,
                        hitPoints: 200,
                        location,
                    };

                    // Make the location traversable and set the unit in it
                    location.value = '.';
                    location.unit = unit;

                    return unit;
                });

            console.log('Map', map);
            console.log('Units', units);
            console.log('-----');

            const unitInfo = unit => {
                const {type, location, hitPoints} = unit;
                return {
                    type,
                    hitPoints,
                    x: location.x,
                    y: location.y,
                };
            };

            console.log(map.toString(location => location.unit?.type || location.value));

            // Used for pathfinding
            const isObstacle = location => location.value === '#' || location.unit !== undefined;
            const isTraversable = location => (
                location !== undefined
                && location.value !== '#'
                && location.unit === undefined
            );

            const getAdjacentTargetUnit = unit => {
                const {up, left, right, down} = unit.location.getAdjacentItems(true);

                return [up, left, right, down]
                    .filter(location => location.unit !== undefined && location.unit.type !== unit.type)
                    // Pick the one with the least amount of hit points
                    .sort((a, b) => a.unit.hitPoints - b.unit.hitPoints)
                    .at(0)
                    ?.unit;
            };

            let completedRounds = 0;
            while (true) {
                console.groupCollapsed('Round', completedRounds + 1);
                const unitLocations = map.filter2d(location => (location.unit !== undefined), true);

                // Stop if there are no targets any more
                if (unitLocations.map(location => location.unit.type).unique().length === 1) {
                    break;
                }

                const defeatedUnits = [];

                for (let i = 0; i < unitLocations.length; i++) {
                    const currentUnit = unitLocations[i].unit;
                    let targetUnit = getAdjacentTargetUnit(currentUnit);

                    // Move the unit, if there is no target to attack
                    if (targetUnit === undefined) {
                        // Find the shortest path to any target
                        const targetLocation = unitLocations
                            // Keep locations that have an alive target
                            .filter(location => (
                                location.unit.type !== currentUnit.type
                                && location.unit.hitPoints > 0
                            ))
                            // Get the (valid) locations adjacent to the target location
                            .flatMap(location => location.getAdjacentItems().filter(isTraversable))
                            // Find paths to all the target locations
                            .map(location => Pathfinding.aStar(map, currentUnit.location, location, isObstacle))
                            .filter(path => path !== false)
                            // Keep only the last location of each path
                            .map(path => path.at(-1))
                            // Sort by reading order and get the shortest path
                            .sortGrouped('y', (a, b) => a.y - b.y, (a, b) => a.x - b.x)
                            .at(0);

                        // If all targets are unreachable, skip to next unit
                        if (targetLocation === undefined) {
                            continue;
                        }

                        let nextLocation;

                        // Decide what the next step is, based on shortest path (in reading order)
                        const {up, left, right, down} = currentUnit.location.getAdjacentItems(true);
                        if ([up, left, right, down].includes(targetLocation)) {
                            nextLocation = targetLocation;
                        } else {
                            nextLocation = [up, left, right, down]
                                .filter(isTraversable)
                                .map(location =>
                                    [location].concat(Pathfinding.aStar(map, location, targetLocation, isObstacle)))
                                .filter(path => path[1] !== false)
                                .sort((a, b) => a.length - b.length)
                                .at(0)
                                .at(0);
                        }

                        console.log(
                            'Unit', unitInfo(currentUnit),
                            'moves to', `${nextLocation.x},${nextLocation.y}`,
                            'toward', `${targetLocation.x},${targetLocation.y}`
                        );

                        // Move the unit to the next location
                        nextLocation.unit = currentUnit;
                        currentUnit.location.unit = undefined;
                        unitLocations.splice(i, 1, nextLocation);
                        currentUnit.location = nextLocation;

                        // Select a target to attack (if there are any)
                        targetUnit = getAdjacentTargetUnit(currentUnit);
                    }

                    if (targetUnit !== undefined) {
                        console.log(
                            'Unit', unitInfo(currentUnit),
                            'attacks unit', unitInfo(targetUnit),
                        );

                        targetUnit.hitPoints -= 3;

                        // The target unit has been defeated
                        if (targetUnit.hitPoints <= 0) {
                            defeatedUnits.push(targetUnit);
                        }
                    }
                }

                // Remove defeated units
                for (const defeatedUnit of defeatedUnits) {
                    defeatedUnit.location.unit = undefined;
                    units.splice(units.findIndex(unit => unit === defeatedUnit), 1);
                }

                console.log(map.toString(location => location.unit?.type || location.value));
                console.log(units.map(unitInfo));

                console.groupEnd();

                completedRounds++;
            }

            console.log(
                'Rounds completed', completedRounds,
                'Units HP sum', units.reduce((sum, unit) => (sum + unit.hitPoints), 0)
            );

            // const sortByY = (a, b) => a.y - b.y;
            // const sortByX = (a, b) => a.x - b.x;
            // allUnits = allUnits.sortGrouped('y', sortByY, sortByX);

            // 19000 is too low
            document.querySelector('#answer').innerText = completedRounds
                * units.reduce((sum, unit) => (sum + unit.hitPoints), 0);
        </script>
    </body>
</html>
