<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <textarea style="font-size: 25px; width: 500px; height: 150px;">
            2199943210
            3987894921
            9856789892
            8767896789
            9899965678
        </textarea>

        <script type="module">
            import FileReader from '../FileReader.js';
            import Utilities from '../Utilities.js';
            import Parser from './Parser.js';

            const fileReader = new FileReader('./data.txt', new Parser());
            const heightMap = await fileReader.parse();
            const lowestPoints = [];

            // Loop over all X,Y coordinates
            for (let y = 0; y < heightMap.length; y++) {
                for (let x = 0; x < heightMap[0].length; x++) {
                    const current = parseInt(heightMap[y][x], 10);
                    
                    // Add the value, if it's lower than all adjacent values
                    // Non-existing coordinates (undefined) evaluate to true, because no check is possible
                    // A 9 can never be the lowest point
                    if (current !== 9
                        && (heightMap[y - 1] === undefined || current < heightMap[y - 1][x])
                        && (heightMap[y + 1] === undefined || current < heightMap[y + 1][x])
                        && (heightMap[y][x - 1] === undefined || current < heightMap[y][x - 1])
                        && (heightMap[y][x + 1] === undefined || current < heightMap[y][x + 1])) {
                        lowestPoints.push({x, y, value: current});
                    }
                }
            }



            const getBasinRow = (rowIndex, xIndexesToCheck) => {
                const row = heightMap[rowIndex];
                const basinRow = {
                    rowIndex,
                    xIndexes: [],
                    isLastRow: false,
                };

                console.log('Row', basinRow.rowIndex, row, 'Check with indexes', xIndexesToCheck);

                // Loop backwards, because forward would mess up with splice()
                for (let i = xIndexesToCheck.length - 1; i > -1; i--) {
                    const xIndex = xIndexesToCheck[i];

                    // Don't check indexes that are already in the basin
                    if (basinRow.xIndexes.indexOf(xIndex) !== -1) {
                        console.log('Index', xIndex, 'is already collected --> skip to next X');
                        continue;
                    }

                    console.log('Checking with index', xIndex);
                    // Skip if there's a 9 at the X index
                    if (row[xIndex] === '9') {
                        console.log('Row', rowIndex, 'index', xIndex, 'is a 9 --> skip to next X');
                        // Remove the X index for the next row
                        xIndexesToCheck.splice(xIndexesToCheck.indexOf(xIndex), 1);
                        continue;
                    }

                    // Add the current X index
                    console.log('Value is', row[xIndex], '--> add index', xIndex);
                    basinRow.xIndexes.push(xIndex);

                    // Collect indexes to the left and right of the X index, where the value isn't 9
                    let index = xIndex;
                    console.log('To left from index', index);
                    while (--index > -1 && row[index] !== '9') {
                        console.log('Add index', index);
                        basinRow.xIndexes.push(index);
                    }
                    index = xIndex;
                    console.log('To right from index', index);
                    while(++index < row.length && row[index] !== '9') {
                        console.log('Add', index);
                        basinRow.xIndexes.push(index);
                    }

                    basinRow.xIndexes.sort();
                    console.log('>>> X index', xIndex, 'done', basinRow.xIndexes);
                    console.log('');
                }

                // If there are no indexes left to check, don't check additional rows
                if (xIndexesToCheck.length === 0) {
                    console.log('No need to check for more rows');
                    basinRow.isLastRow = true;
                }

                return basinRow;
            };



            const allBasins = [];

            lowestPoints.forEach(point => {
                console.group('>>>>> Point', point);

                const basin = [];

                // First define the first (middle) basin row
                const startBasinRow = getBasinRow(point.y, [point.x]);

                console.log('---------------- Check rows above ----------------------');

                // Clone the indexes array, because they go by reference
                let xIndexesToCheck = startBasinRow.xIndexes.map(item => item);

                // Find basin rows in rows preceding the starting point
                for (let yIndex = (point.y - 1); yIndex > -1; yIndex--) {
                    const basinRow = getBasinRow(yIndex, xIndexesToCheck);
                    if (basinRow.isLastRow) {
                        break;
                    }

                    basin.unshift(basinRow);
                    // Clone the indexes array, because they go by reference
                    xIndexesToCheck = basinRow.xIndexes.map(item => item);
                    console.log('>>>>> Row', yIndex, 'done, Indexes to check in next row', xIndexesToCheck);
                    console.log('');
                }

                // Place the start basin in the middle
                basin.push(startBasinRow);

                // Clone the indexes array, because they go by reference
                xIndexesToCheck = startBasinRow.xIndexes.map(item => item);

                console.log('---------------- Check rows below ----------------------');

                // Find basin rows in rows following the starting point
                for (let yIndex = (point.y + 1); yIndex < heightMap.length; yIndex++) {
                    const basinRow = getBasinRow(yIndex, xIndexesToCheck);
                    if (basinRow.isLastRow) {
                        break;
                    }

                    basin.push(basinRow);
                    // Clone the indexes array, because they go by reference
                    xIndexesToCheck = basinRow.xIndexes.map(item => item);
                    console.log('>>>>> Row', yIndex, 'done, Indexes to check in next row', xIndexesToCheck);
                    console.log('');
                }

                allBasins.push(basin);
                console.groupEnd();
            });



            /* (function makeBasinGraph(allBasins) {
                const basinMap = heightMap.map(item => item);

                allBasins.forEach(basin => {
                    for (let row of basin) {
                        console.log(basin);
                        for (let xIndex of row.xIndexes) {
                            const newRow = basinMap[row.rowIndex].replace('9', '_').split('');
                            newRow[xIndex] = '*';
                            basinMap[row.rowIndex] = newRow.join('');
                        }
                    }
                });

                console.log(basinMap.join("\n"));
            })(allBasins); */



            console.log('All basins', allBasins);

            console.log('All basins, only x indexes', allBasins.map(basin => {
                return basin.map(properties => properties.xIndexes.join(' '));
            }));

            // 812820 is too low

            const largestBasins = allBasins
                .map(basin => {
                    const xIndexArrays = basin.map(properties => properties.xIndexes);
                    // Concatenate all the X index arrays
                    return [].concat(...xIndexArrays);
                })
                // Sort by index amount (descending)
                .sort((indexesA, indexesB) => indexesB.length - indexesA.length)
                // Take the three highest amounts
                .slice(0, 3);
            console.log('Largest basins', largestBasins);
            answer.innerText = largestBasins
                // Multiply the amounts
                .reduce((sum, indexes) => (sum * indexes.length), 1);
        </script>
    </body>
</html>
