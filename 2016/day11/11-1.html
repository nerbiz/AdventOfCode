<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../../FileReader.js';
            import Parser from './Parser.js';

            const fileReader = new FileReader('./datatest.txt', new Parser());
            const floors = await fileReader.parse();
            const itemsAmount = floors.flat().length;
            let fewestSteps = Infinity;

            const startTime = new Date().getTime();

            /* const visualizeFloors = floors => floors.map(floor =>
                floor.map(item => item.element + '-' + item.type.at(0).toUpperCase())
            );

            console.log('Original', visualizeFloors(floors)); */

            /*
            0: ['promethium-G', 'promethium-M']
            1: ['cobalt-G', 'curium-G', 'ruthenium-G', 'plutonium-G']
            2: ['cobalt-M', 'curium-M', 'ruthenium-M', 'plutonium-M']
            3: []
            */



            const floorStateString = (index, floor) => {
                return index + ':' + floor
                    .map(item => item.element + '-' + item.type)
                    .sort()
                    .join(',');
            };

            const initialFloorStates = floors.filter(floor => floor.length > 0)
                .map((floor, index) => floorStateString(index, floor));

            const traverseFloors = (floors, floorIndex = 0, steps = 0, floorStates = initialFloorStates) => {
                // if (steps > 200) {
                //     console.log('Forget it');
                //     return;
                // }

                // Stop if the amount of steps is already higher than the current lowest
                if (steps >= fewestSteps) {
                    // console.log('Too many steps, stop here');
                    return;
                }

                // See if all the items are at the top floor
                if (floors[3].length === itemsAmount) {
                    console.log('Target reached in', steps, 'steps');
                    fewestSteps = steps;
                    return;
                }

                // If there is at least one generator on the same floor as a microchip,
                // one of them has to be correspond to the microchip
                for (const floor of floors) {
                    // No need to check an empty floor
                    if (floor.length === 0) {
                        continue;
                    }

                    // It's safe if there are no generators
                    const generators = floor.filter(item => item.type === 'generator');
                    if (generators.length === 0) {
                        continue;
                    }

                    for (const microchip of floor.filter(item => item.type === 'microchip')) {
                        const corresponding = generators
                            .find(generator => generator.element === microchip.element);

                        // The chip is fried
                        if (corresponding === undefined) {
                            // console.log('Fried!', microchip);
                            return;
                        }
                    }
                }

                // Find all combinations for moving items
                const moveCombinations = [];
                for (let i = 0; i < floors[floorIndex].length; i++) {
                    const firstItem = floors[floorIndex][i];

                    // Move as many as possible, so start with combinations of 2 items
                    for (const secondItem of floors[floorIndex].slice(i + 1)) {
                        moveCombinations.push([firstItem, secondItem]);
                    }

                    // Then add combinations for single item moving
                    moveCombinations.push([firstItem]);
                }

                for (const upDown of [1, -1]) {
                    // See if the elevator can go up/down
                    if (floors[floorIndex + upDown] === undefined) {
                        continue;
                    }

                    const nextFloorIndex = floorIndex + upDown;
                    for (const combination of moveCombinations) {
                        // Add the item(s) to the next floor, remove from the current
                        const floorsCopy = floors.map(floor => floor.map(item => item));
                        floorsCopy[nextFloorIndex] = floorsCopy[nextFloorIndex].concat(combination);
                        floorsCopy[floorIndex] = floorsCopy[floorIndex].filter(item => ! combination.includes(item));

                        // Don't repeat any previous step, to avoid infinite loops
                        const floorState = floorStateString(nextFloorIndex, floorsCopy[nextFloorIndex]);
                        if (floorStates.includes(floorState)) {
                            continue;
                        }

                        traverseFloors(floorsCopy, nextFloorIndex, steps + 1, floorStates.concat(floorState));
                    }
                }
            };

            traverseFloors(floors);

            console.log('Done in ms:', new Date().getTime() - startTime);

            document.querySelector('#answer').innerText = fewestSteps;
        </script>
    </body>
</html>
