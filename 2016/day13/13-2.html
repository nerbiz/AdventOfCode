<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../../FileReader.js';
            import Parser from './Parser.js';
            import Array2d from '../../Array2d.js';
            import ArrayPrototype from '../../ArrayPrototype.js';

            ArrayPrototype.extend();
            const fileReader = new FileReader('./data.txt', new Parser());
            const {number, target} = await fileReader.parse();
            const valueFormula = (x, y) => {
                const decimal = (x * x) + (3 * x) + (2 * x * y) + y + (y * y) + number;
                const binary = decimal.toString(2);
                // True = open space, false = wall
                return (binary.split('').filter(bit => bit === '1').length % 2 === 0);
            };
            const maze = Array2d.withData({
                value: (x, y) => valueFormula(x, y),
                G: undefined,
                F: undefined,
                previous: undefined,
            }, target[1] * 2, target[0] * 2);

            const getHeuristic = (startNode, endNode) => {
                return Math.abs(endNode.x - startNode.x) + Math.abs(endNode.y - startNode.y);
            };

            // Use the A* algorithm
            const startNode = maze.getItem(1, 1);
            const endNode = maze.getItem(target[0], target[1]);
            startNode.G = 0;
            startNode.F = startNode.G + getHeuristic(startNode, endNode);
            startNode.inPath = true;

            const queue = [startNode];
            const visited = [];

            while (queue.length > 0) {
                const currentNode = queue.sort((a, b) => a.F - b.F).shift();
                visited.push(currentNode);

                // Don't look further with the current node,
                // if the maximum distance to the start node has been reached
                if (currentNode.G === 50) {
                    continue;
                }

                // Stop after a maximum amount of nodes has been visited
                if (visited.length === 200) {
                    break;
                }

                for (const neighbor of currentNode.getAdjacentItems()) {
                    if (neighbor === undefined
                        // The node must not be an obstacle
                        || neighbor.value === false
                        // The node must not be visited yet
                        || visited.includes(neighbor)
                    ) {
                        continue;
                    }

                    // Calculate the F value of the neighbor
                    const G = (currentNode.G + 1);
                    const F = G + Math.abs(endNode.x - neighbor.x)
                        + Math.abs(endNode.y - neighbor.y);

                    // Update the neighbor's values if it's not in the queue,
                    // or if it is in the queue, but the F is lower
                    const inQueue = queue.includes(neighbor);
                    if (! inQueue || (inQueue && F < neighbor.F)) {
                        neighbor.G = G;
                        neighbor.F = F;
                        neighbor.previous = currentNode;
                    }

                    // Add the neighbor to the queue
                    if (! inQueue) {
                        queue.push(neighbor);
                    }
                }
            }

            // Visualize the maze
            console.log(maze.toString(node => {
                if (visited.includes(node)) {
                    return 'â–ˆ';
                }

                return node.value ? '.' : '#';
            }));

            document.querySelector('#answer').innerText = visited.unique().length;
        </script>
    </body>
</html>
