<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../../FileReader.js';
            import Parser from './Parser.js';
            import Array2d from '../../Array2d.js';

            const fileReader = new FileReader('./data.txt', new Parser());
            const map = new Array2d(await fileReader.parse());
            const numberNodes = map.filter2d(item => (Number.isInteger(item.value)), true);
            let shortestDistance = Infinity;

            // Find path using the A* algorithm
            const findPath = (startNode, endNode) => {
                // Reset pathfinding properties of all nodes
                map.forEach2d(node => {
                    node.G = undefined;
                    node.F = undefined;
                    node.previous = undefined;
                });

                startNode.G = 0;
                startNode.F = startNode.G + Math.abs(endNode.x - startNode.x)
                    + Math.abs(endNode.y - startNode.y);
                // startNode.inPath = true;

                const queue = [startNode];
                const visited = [];
                const path = [];

                while (queue.length > 0) {
                    let currentNode = queue.sort((a, b) => a.F - b.F).shift();
                    visited.push(currentNode);

                    // Target reached, construct the path using 'previous' property
                    if (currentNode === endNode) {
                        while (currentNode.previous !== undefined) {
                            // currentNode.inPath = true;
                            path.push(currentNode);
                            currentNode = currentNode.previous;
                        }

                        break;
                    }

                    for (const neighbor of currentNode.getAdjacentItems()) {
                        if (neighbor === undefined
                            // The node must not be an obstacle
                            || neighbor.value === false
                            // The node must not be visited yet
                            || visited.includes(neighbor)
                        ) {
                            continue;
                        }

                        // Calculate the F value of the neighbor
                        const G = (currentNode.G + 1);
                        const F = G + Math.abs(endNode.x - neighbor.x)
                            + Math.abs(endNode.y - neighbor.y);

                        // Update the neighbor's values if it's not in the queue,
                        // or if it is in the queue, but the F is lower
                        const inQueue = queue.includes(neighbor);
                        if (! inQueue || (inQueue && F < neighbor.F)) {
                            neighbor.G = G;
                            neighbor.F = F;
                            neighbor.previous = currentNode;
                        }

                        // Add the neighbor to the queue
                        if (! inQueue) {
                            queue.push(neighbor);
                        }
                    }
                }

                // Reverse the path, to go from start to end
                return path.reverse();
            }

            // Find all possible combinations for visiting every target node
            const startNode = numberNodes.find(node => node.value === 0);
            const allCombinations = [];
            (function findCombinations(path, remaining) {
                if (remaining.length === 0) {
                    // Add the start node to the start and end of the path
                    path.unshift(startNode);
                    path.push(startNode);
                    allCombinations.push(path);
                    return;
                }

                for (const node of remaining) {
                    // Clone the arrays
                    const pathCopy = path.map(node => node);
                    const remainingCopy = remaining.map(node => node);

                    // Add the node to the path
                    pathCopy.push(node);

                    // Repeat with the remaining nodes
                    findCombinations(pathCopy, remainingCopy.filter(otherNode => otherNode !== node));
                }
            })([], numberNodes.filter(node => node.value !== 0));

            // Find all paths between all targets
            for (const node of numberNodes) {
                node.paths = {};

                const targetNodes = numberNodes.filter(targetNode => targetNode !== node);
                for (const targetNode of targetNodes) {
                    node.paths[targetNode.value] = findPath(node, targetNode);
                }
            }

            // Find the shortest distance
            combinationsLoop: for (const combination of allCombinations) {
                let distance = 0;

                // Skip the last node, because of start-end pairs
                for (let i = 0; i < combination.length - 1; i++) {
                    const startNode = combination[i];
                    const endNode = combination[i + 1];
                    distance += startNode.paths[endNode.value].length;

                    // Stop looking, if the path is already longer than the shortest
                    if (distance > shortestDistance) {
                        continue combinationsLoop;
                    }
                }

                // Update the shortest distance
                shortestDistance = distance;
            }

            document.querySelector('#answer').innerText = shortestDistance;
        </script>
    </body>
</html>
