<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <link rel="stylesheet" href="../../style.css">
    </head>
    <body>
        <p class="answer"></p>

        <script type="module">
            import FileReader from '../../classes/FileReader.js';
            import Parser from './Parser.js';

            const fileReader = new FileReader('./datatest.txt', new Parser());
            const itemObjects = (await fileReader.parse())
                .flatMap((contents, floor) => contents.map(item => {
                    const [element, type] = item.split(' ');
                    return {floor, element, type};
                }))
                // Sort items by type and element
                .sort((a, b) => (a.type === b.type)
                    ? (a.element < b.element ? -1 : 1)
                    : (a.type < b.type ? 1 : -1)
                );

            console.time('Time elapsed');

            const itemsAmount = itemObjects.length;

            // Make multipliers for the item locations
            // Example: increase first digit of 2222 with 1000
            const multipliers = [];
            for (let i = 0; i < itemsAmount; i++) {
                multipliers[i] = 10 ** (itemObjects.length - i - 1);
            }

            // The goal is when all items are at the 4th floor
            const goal = (3).toString(10).repeat(itemsAmount) - 0;

            // Convert the building state to a number
            // Example: 1032, if 4 items are on floors 1, 0, 2 and 3
            // Example:    2, if 4 items are on floors 0, 0, 0 and 2
            let items = 0;
            for (let i = 0; i < itemObjects.length; i++) {
                // Place digits in order by multiplying by powers of 10
                items += itemObjects[i].floor * multipliers[i];
            }

            /**
             * Check if any microchip is fried
             * @param {string} itemsString
             * @param {string} indexes
             * @returns {boolean}
             */
            const microchipFried = (itemsString, indexes) => {
                const half = itemsString.length / 2;

                for (let i = 0; i < indexes.length; i++) {
                    // Only check the microchips
                    if (indexes[i] >= half) {
                        continue;
                    }

                    // Chip and generator index difference is half the items amount
                    // If that index exists, the chip is safe
                    if (indexes.includes((indexes[i] - 0) + half)) {
                        continue;
                    }

                    // If not, the chip is fried if there are generators
                    for (let j = i + 1; j < indexes.length; j++) {
                        if (indexes[j] >= half) {
                            return true;
                        }
                    }
                }

                return false;
            };

            let fewestSteps = Infinity;
            let loopCount = 0;
            let skipped = 0;
            const succeededStates = new Set();
            const failedStates = new Set();

            const findFewestSteps = (items, floor = 0, path = []) => {
                if (++loopCount === 1e6) {
                    throw new Error('Too much recursion');
                }

                // See if all items are on the top floor
                if (items === goal) {
                    if (path.length < fewestSteps) {
                        fewestSteps = path.length;
                        console.log({fewestSteps});
                    }

                    return;
                }

                // Stop if the amount of steps is already larger than the fewest
                if (path.length >= fewestSteps) {
                    skipped++;
                    return;
                }

                // Don't check an already known failed state
                if (failedStates.has(items)) {
                    skipped++;
                    return;
                }

                // Don't repeat a previous state
                // (Copy the path to avoid same-reference)
                path = path.slice(0);
                if (path.includes(items)) {
                    skipped++;
                    return;
                }
                path.push(items);

                const itemsString = items.toString(10).padStart(itemsAmount, '0');

                // Set the minimum floor, for not going back down to empty floors
                // And get the items that are on the current floor
                let minimumFloor = Infinity;
                let floorItemIndexes = '';
                for (let i = 0; i < itemsString.length; i++) {
                    minimumFloor = Math.min(minimumFloor, (itemsString[i] - 0));

                    if (itemsString[i] - 0 === floor) {
                        floorItemIndexes += i;
                    }
                }

                // Check if any microchips are fried
                if (
                    ! succeededStates.has(items)
                    && microchipFried(itemsString, floorItemIndexes)
                ) {
                    skipped++;
                    failedStates.add(items);
                    return;
                }

                succeededStates.add(items);

                for (const move of [-1, 1]) {
                    const nextFloor = floor + move;
                    if (nextFloor < minimumFloor || nextFloor > 3) {
                        continue;
                    }

                    for (let i = 0; i < floorItemIndexes.length; i++) {
                        const oneItem = items + (multipliers[floorItemIndexes[i]] * move);

                        // Try to move 2 items
                        for (let j = i + 1; j < floorItemIndexes.length; j++) {
                            const twoItems = oneItem + (multipliers[floorItemIndexes[j]] * move);
                            findFewestSteps(twoItems, nextFloor, path);
                        }

                        // If moving 2 items failed, try to move 1 item
                        findFewestSteps(oneItem, nextFloor, path);
                    }
                }
            };

            findFewestSteps(items);

            console.log({loopCount});
            console.log({skipped});

            document.querySelector('.answer').innerText = fewestSteps;
            console.timeEnd('Time elapsed');
        </script>
    </body>
</html>
