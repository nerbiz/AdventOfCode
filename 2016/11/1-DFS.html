<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <link rel="stylesheet" href="../../style.css">
    </head>
    <body>
        <p class="answer"></p>

        <script type="module">
            import FileReader from '../../classes/FileReader.js';
            import Parser from './Parser.js';

            const fileReader = new FileReader('./datatest.txt', new Parser());
            const items = (await fileReader.parse())
                .flatMap((contents, floor) => contents.map(item => {
                    const [element, type] = item.split(' ');
                    return {floor, element, type};
                }));

            console.time('Time elapsed');

            /**
             * Check if any microchip is fried
             * @return {boolean}
             */
            const microchipFried = () => {
                // Sort items by type and element
                const itemsSorted = items.slice(0).sort((a, b) => (a.type === b.type)
                    ? (a.element < b.element ? -1 : 1)
                    : (a.type < b.type ? -1 : 1)
                );

                // First half is generators, second half is microchips
                const generators = itemsSorted.slice(0, itemsSorted.length / 2);
                const microchips = itemsSorted.slice(itemsSorted.length / 2);

                for (let i = 0; i < microchips.length; i++) {
                    // See if the chip is protected by its corresponding generator
                    if (generators[i].floor === microchips[i].floor) {
                        continue;
                    }

                    // If not, the chip is fried if there is a different generator
                    for (const generator of generators) {
                        if (generator.floor === microchips[i].floor) {
                            return true;
                        }
                    }
                }

                return false;
            };

            /**
             * Get a string representing the current items state
             * @return {string}
             */
            const getStateString = () => {
                let string = '';
                for (let x = 0; x < items.length; x++) {
                    string += x + ',' + items[x].floor;
                }

                return string;
            };

            let fewestSteps = Infinity;
            let loopCount = 0;
            const succeededStates = new Set();
            const failedStates = new Set();

            const findFewestSteps = (floor = 0, steps = -1, states = []) => {
                if (++loopCount === 1e6) {
                    throw new Error('Too much recursion');
                }

                // Stop if the amount of steps is already larger than the fewest
                if (++steps >= fewestSteps) {
                    return;
                }

                // Don't check an already known failed state
                const state = getStateString();
                if (failedStates.has(state)) {
                    return;
                }

                // Don't repeat a previous state
                if (states.includes(state)) {
                    return;
                }
                states.push(state);

                // Set the minimum floor, for not going back down to empty floors
                const minimumFloor = Math.min(...items.map(item => item.floor));

                // See if all items are on the top floor
                if (minimumFloor === 3) {
                    if (steps < fewestSteps) {
                        fewestSteps = steps;
                        console.log({fewestSteps});
                    }

                    return;
                }

                // Check if any microchips are fried
                if (! succeededStates.has(state) && microchipFried()) {
                    failedStates.add(state);
                    return;
                }

                succeededStates.add(state);
                const floorItems = items.filter(item => item.floor === floor);

                for (const move of [-1, 1]) {
                    const nextFloor = floor + move;
                    if (nextFloor < minimumFloor || nextFloor < 0 || nextFloor > 3) {
                        continue;
                    }

                    for (let i = 0; i < floorItems.length; i++) {
                        const item1 = floorItems[i];
                        item1.floor += move;

                        // Try to move 2 items
                        for (const item2 of floorItems.slice(i + 1)) {
                            item2.floor += move;
                            findFewestSteps(nextFloor, steps, states.slice(0));
                            // Revert to previous floor after trying
                            item2.floor += move * -1;
                        }

                        // If moving 2 items failed, try to move 1 item
                        findFewestSteps(nextFloor, steps, states.slice(0));
                        // Revert to previous floor after trying
                        item1.floor += move * -1;
                    }
                }
            };

            findFewestSteps();

            console.log({loopCount});

            document.querySelector('.answer').innerText = fewestSteps;
            console.timeEnd('Time elapsed');
        </script>
    </body>
</html>
