<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <link rel="stylesheet" href="../../style.css">
    </head>
    <body>
        <p class="answer"></p>

        <script type="module">
            import FileReader from '../../classes/FileReader.js';
            import Parser from './Parser.js';
            import Array2d from '../../classes/Array2d.js';
            import Pathfinding from '../../classes/Pathfinding.js';

            const fileReader = new FileReader('./datatest.txt', new Parser());
            const burrow = new Array2d(await fileReader.parse());
            let leastEnergyUsed = Infinity;

            console.time('Time taken');

            // Set the destinations in the burrow
            [burrow.getItem(3, 2), burrow.getItem(3, 3)].forEach(location => location.destinationFor = 'A');
            [burrow.getItem(5, 2), burrow.getItem(5, 3)].forEach(location => location.destinationFor = 'B');
            [burrow.getItem(7, 2), burrow.getItem(7, 3)].forEach(location => location.destinationFor = 'C');
            [burrow.getItem(9, 2), burrow.getItem(9, 3)].forEach(location => location.destinationFor = 'D');

            // An amphipod will not stop in front of a room
            [
                burrow.getItem(3, 1), burrow.getItem(5, 1),
                burrow.getItem(7, 1), burrow.getItem(9, 1)
            ].forEach(location => location.skip = true);

            // Create amphipod objects in locations that have amphipod
            burrow.forEach2d(location => {
                if (location.value.match(/[A-D]/) !== null) {
                    const type = location.value;
                    const locationDown = burrow.getItem(location.x, location.y + 1);

                    location.value = '.';
                    location.amphipod = {
                        type,
                        // A = 1, B = 10, C = 100, D = 1000
                        energyPerStep: 10 ** (type.charCodeAt(0) - 65),
                        // See if the amphipod is at its destination already
                        atDestination: (
                            type === location.destinationFor
                            && (locationDown.value === '#' || locationDown.amphipod?.type === type)
                        ),
                    };
                }
            });

            console.log(burrow.toString());

            // Used for pathfinding
            const isObstacle = location => location.value === '#' || location.amphipod !== undefined;

            let count = 0;
            const max = 2e4;

            const takeStep = (burrow, energyUsed = 0) => {
                if (++count === max) {
                    console.timeEnd('Time taken');
                    throw new Error(`Too many loops: ${max}`);
                }

                // Stop if the used energy is already more than the least
                if (energyUsed >= leastEnergyUsed) {
                    return;
                }

                const locationsWithRemainingAmphipods = burrow
                    .filter2d(location => (
                        location.amphipod !== undefined
                        && location.amphipod.atDestination === false
                    ), true)
                    .sort((a, b) => a.amphipod.energyPerStep - b.amphipod.energyPerStep);

                // See if all amphipods are at their destination
                if (locationsWithRemainingAmphipods.length === 0) {
                    leastEnergyUsed = Math.min(leastEnergyUsed, energyUsed);
                    console.log('All at destination! Used energy:', energyUsed);
                    console.log(burrow.toString(location => (location.amphipod !== undefined)
                        ? location.amphipod.type
                        : location.value));
                    return;
                }

                for (const location of locationsWithRemainingAmphipods) {
                    const amphipod = location.amphipod;

                    // An amphipod only moves to the hallway, if not already in it
                    const targetLocations = (location.y > 1)
                        ? burrow.slice2d(1, 1, burrow[1].length - 1, 2)
                            .flat()
                            .filter(location => location.skip !== true)
                        : [];

                    // Destinations take precedence
                    const destinations = burrow
                        .filter2d(location => (location.destinationFor === amphipod.type), true)
                        .sort((a, b) => a.y - b.y);
                    if (destinations[1].amphipod === undefined) {
                        targetLocations.unshift(destinations[1]);
                    } else if (destinations[0].amphipod === undefined
                        && destinations[1].amphipod?.type === amphipod.type
                    ) {
                        targetLocations.unshift(destinations[0]);
                    }

                    for (let targetLocation of targetLocations) {
                        const burrowCopy = burrow.clone();
                        const currentLocation = burrowCopy.getItem(location.x, location.y);
                        targetLocation = burrowCopy.getItem(targetLocation.x, targetLocation.y);
                        const path = Pathfinding.aStar(burrowCopy, location, targetLocation, isObstacle);
                        if (path === false) {
                            continue;
                        }

                        // console.log(
                        //     'Amphipod', amphipod.type,
                        //     'moving from', location.x, location.y,
                        //     'to', targetLocation.x, targetLocation.y,
                        //     'using energy:', path.length * amphipod.energyPerStep,
                        // );

                        // Move the amphipod to the new location and see if it's at its destination
                        targetLocation.amphipod = currentLocation.amphipod;
                        currentLocation.amphipod = undefined;
                        targetLocation.amphipod.atDestination = (targetLocation.y > 1);

                        takeStep(burrowCopy, energyUsed + (path.length * amphipod.energyPerStep));
                    }
                }
            };

            takeStep(burrow);

            document.querySelector('.answer').innerText = leastEnergyUsed;
        </script>
    </body>
</html>
