<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <link rel="stylesheet" href="../../style.css">
    </head>
    <body>
        <p class="answer"></p>

        <script type="module">
            import FileReader from '../../classes/FileReader.js';
            import Parser from './Parser.js';

            const fileReader = new FileReader('./datatest.txt', new Parser());
            const positions = await fileReader.parse();

            console.time('Time elapsed');

            // Make the positions 0-based
            positions[0]--;
            positions[1]--;

            // Create all possible dice roll outcomes
            let universesPerTurn = 0;
            const possibleOutcomes = {};
            for (let rollOne = 1; rollOne <= 3; rollOne++) {
                for (let rollTwo = 1; rollTwo <= 3; rollTwo++) {
                    for (let rollThree = 1; rollThree <= 3; rollThree++) {
                        // Each outcome means 3 universes,
                        // and each outcome can happen multiple times
                        const outcome = rollOne + rollTwo + rollThree;
                        possibleOutcomes[outcome] = possibleOutcomes[outcome] || 0;
                        possibleOutcomes[outcome] += 3;
                        universesPerTurn += 3;
                    }
                }
            }

            console.log(possibleOutcomes);
            console.log({universesPerTurn});

            const reach21 = (position, outcomes = '', score = 0, reached = [], notReached = []) => {
                for (const outcome in possibleOutcomes) {
                    const newOutcomes = outcomes + outcome;
                    const newPosition = (position + (outcome - 0)) % 10;
                    const newScore = score + newPosition + 1;

                    if (newScore >= 21) {
                        // Group the wins by turns amount
                        reached[newOutcomes.length] = reached[newOutcomes.length] || [];
                        reached[newOutcomes.length].push(newOutcomes);
                        continue;
                    }

                    notReached[newOutcomes.length] = notReached[newOutcomes.length] || [];
                    notReached[newOutcomes.length].push(newOutcomes);
                    reach21(newPosition, newOutcomes, newScore, reached, notReached);
                }

                return [reached, notReached];
            };

            // Create an array of winning universes amount, where index is turns amount
            const reachedUnreached = [
                reach21(positions[0]),
                reach21(positions[1]),
            ];

            /*
            Plan:
            - Voor elke hoeveelheid rondes waarin P1 wint (3 rondes t/m 10 rondes)
            - Bijvoorbeeld: P1 wint in 4 rondes
                - Verliezende rondes van P2 pakken (3 rondes: als P1 in 4 rondes wint, deed P2 3 rondes)
                - Hoeveelheid mogelijkheden om in 4 rondes te winnen pakken
                - Vermenigvuldigen met de verliezende rondes
                    - Want bij elke optie van winnen in 4 rondes, zijn alle verliezende 3 rondes mogelijk
                - Optellen bij winnend aantal rondes
                    - 3334, 3335, 3336.. bijvoorbeeld, daarvan alle mogelijkheden optellen
            */

            console.log(reachedUnreached);

            const p1Wins = reachedUnreached[0][0].map(outcomes => {
                return outcomes.map(outcome => {
                    return outcome.split('')
                        .map(outcome => possibleOutcomes[outcome])
                        .reduce((total, universes) => total * universes, 1);
                }).reduce((total, universes) => total + universes, 0);
            });
            const p1Loses = reachedUnreached[0][1].map(outcomes => {
                return outcomes.map(outcome => {
                    return outcome.split('')
                        .map(outcome => possibleOutcomes[outcome])
                        .reduce((total, universes) => total * universes, 1);
                }).reduce((total, universes) => total + universes, 0);
            });
            const p2Wins = reachedUnreached[1][0].map(outcomes => {
                return outcomes.map(outcome => {
                    return outcome.split('')
                        .map(outcome => possibleOutcomes[outcome])
                        .reduce((total, universes) => total * universes, 1);
                }).reduce((total, universes) => total + universes, 0);
            });
            const p2Loses = reachedUnreached[1][1].map(outcomes => {
                return outcomes.map(outcome => {
                    return outcome.split('')
                        .map(outcome => possibleOutcomes[outcome])
                        .reduce((total, universes) => total * universes, 1);
                }).reduce((total, universes) => total + universes, 0);
            });
            console.log({p1Wins});
            console.log({p2Loses});

            const answerPerhaps = p1Wins
                .map((universes, turns) => {
                    const loses = p2Loses.filter((universes2, turns2) => turns2 < turns - 1)
                        .reduce((total, universes) => total + universes, 0);

                    return universes + (reachedUnreached[0][0][turns].length * loses);
                })
                .reduce((total, universes) => total + universes, 0);

            console.log({answerPerhaps});
            console.log('Digits:', answerPerhaps.toString(10).length);

            throw new Error('Done');

            console.log(winningUniverses[0].map(winning => {
                let total = 0;
                for (const outcomes of winning) {
                    let universes = 1;
                    for (const outcome of outcomes) {
                        universes *= possibleOutcomes[outcome];
                    }
                    total += universes;
                }
                return total;
            }));
            console.log(winningUniverses[1].map(winning => {
                let total = 0;
                for (const outcomes of winning) {
                    let universes = 1;
                    for (const outcome of outcomes) {
                        universes *= possibleOutcomes[outcome];
                    }
                    total += universes;
                }
                return total;
            }));

            console.log(
                winningUniverses[0].flat()
                    .map(rounds => rounds.split('')
                        .reduce((total, outcomes) => total * possibleOutcomes[outcomes], 1)
                    ).reduce((total, universes) => total + universes, 0),
                winningUniverses[1].flat()
                    .map(rounds => rounds.split('')
                        .reduce((total, outcomes) => total * possibleOutcomes[outcomes], 1)
                    ).reduce((total, universes) => total + universes, 0),
            );

            throw new Error('Done');

            console.log(winningUniverses);

            const totals = [[], []];
            for (let turns = 3; turns <= 10; turns++) {
                const wins = [
                    winningUniverses[0][turns]
                        .map(rounds => rounds.split('')
                            .reduce((total, outcomes) => total * possibleOutcomes[outcomes], 1)
                        ).reduce((total, universes) => total + universes, 0),
                    (winningUniverses[1][turns - 1] || [])
                        .map(rounds => rounds.split('')
                            .reduce((total, outcomes) => total * possibleOutcomes[outcomes], 1)
                        ).reduce((total, universes) => total + universes, 0)
                ];

                const loses = [
                    (universesPerTurn ** turns) - wins[0],
                    (universesPerTurn ** (turns - 1)) - wins[1],
                ];

                totals[0][turns] = wins[0]/* + loses[1]*/;
                totals[1][turns - 1] = wins[1]/* + loses[0]*/;
            }

            console.log('Totals', totals);
            console.log('Total', totals.map(
                total => total.reduce((total, universes) => total + universes, 0)
            ));
            console.log('Digits', totals.map(
                total => total.reduce((total, universes) => total + universes, 0).toString(10).length
            ));

            // document.querySelector('.answer').innerText =
            console.log('');
            console.timeEnd('Time elapsed');
        </script>
    </body>
</html>
