<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            #answer {
                font-size: 25px;
            }
        </style>
    </head>
    <body>
        <p id="answer"></p>

        <script type="module">
            import FileReader from '../FileReader.js';
            import Parser from './Parser.js';
            import Utilities from '../Utilities.js';

            const fileReader = new FileReader('./data.txt', new Parser());
            const connections = await fileReader.parse();

            // Create an array of cave objects
            let caves = [];
            Utilities.map2D(connections, caveName => {
                // Add the cave if it doesn't exist yet
                if (caves.find(cave => cave.name === caveName) === undefined) {
                    caves.push({
                        name: caveName,
                        isSmall: (caveName === caveName.toLowerCase()),
                        connections: [],
                    });
                }
            });

            // Add all the cave connections
            connections.forEach(connection => {
                const caveOne = caves.find(cave => cave.name === connection[0]);
                const caveTwo = caves.find(cave => cave.name === connection[1]);
                caveOne.connections.push(caveTwo);
                caveTwo.connections.push(caveOne);
            });

            // Will contain all possible paths
            const paths = [];

            const traverseCave = (fromCave, path, traversedTwice) => {
                path = (path === undefined) ? [] : path;
                traversedTwice = (traversedTwice === undefined) ? false : traversedTwice;

                // If the cave is small and has been traversed before, see if a second time is allowed
                if (path.includes(fromCave.name) && fromCave.isSmall) {
                    // The start and end cave can never be traversed twice
                    if (traversedTwice === true || ['start', 'end'].includes(fromCave.name)) {
                        return;
                    }

                    traversedTwice = true;
                }

                // Add the current cave to the path
                path.push(fromCave.name);

                // A path is completed
                if (fromCave.name === 'end') {
                    paths.push(path);
                    return;
                }

                // Traverse over the connected caves
                for (let i = 0; i < fromCave.connections.length; i++) {
                    // Use a clone of the path, to avoid reference bugs
                    traverseCave(fromCave.connections[i], Utilities.clone(path), traversedTwice);
                }
            };

            const startCave = caves.find(cave => cave.name === 'start');
            traverseCave(startCave);

            answer.innerText = paths.length;
        </script>
    </body>
</html>
