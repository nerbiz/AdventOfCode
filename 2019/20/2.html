<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <link rel="stylesheet" href="../../style.css">
    </head>
    <body>
        <p class="answer"></p>

        <script type="module">
            import FileReader from '../../classes/FileReader.js';
            import Parser from './Parser.js';
            import ArrayPrototype from '../../classes/ArrayPrototype.js';
            import Array2d from '../../classes/Array2d.js';
            import Pathfinding from '../../classes/Pathfinding.js';

            ArrayPrototype.registerTake();
            ArrayPrototype.registerTap();
            const fileReader = new FileReader('./datatest2.txt', new Parser(), false);
            const maze = new Array2d(await fileReader.parse());
            const letterRegExp = /[A-Z]/;
            const unreachableNode = maze.getItem(0, 0);
            const isObstacle = node => node.value === '#' || letterRegExp.test(node.value);

            /*
            Plan:
            - Outer/inner node detection: whether the . node is left, right, up or down
            - Each node needs a nextFloor property (1 or -1)
            - Limit of going down is amount of inner portals? Stop if floor amount is larger than portal amount?
            - Recursive function needs a currentFloor parameter
            */

            /*const portalNodes = maze.filter2d(node => node.value === '.')
                .filter(node => node
                    .getAdjacentItems()
                    .filter(neighbour => letterRegExp.test(neighbour.value))
                    .length > 0
                )
                .map(node => {
                    let adjacent = node.getAdjacentItems(true);

                    let direction;
                    let letterNode;
                    for (direction in adjacent) {
                        if (letterRegExp.test(adjacent[direction].value)) {
                            letterNode = adjacent[direction];
                            break;
                        }
                    }

                    adjacent = letterNode.getAdjacentItems(true)[direction];
                    console.log({direction, letterNode});
                    throw new Error('Done');
                });*/






            /*const startNode = portalNodes.find(node => node.portalName === 'AA');
            const targetNode = portalNodes.find(node => node.portalName === 'ZZ');
            let fewestSteps = Infinity;

            (function findTarget(fromNode, steps = 0, visited = []) {
                // Stop if the amount of steps is already larger than the fewest
                if (steps >= fewestSteps) {
                    return;
                }

                // Stop if the target node is found
                if (fromNode === targetNode) {
                    fewestSteps = steps;
                    return;
                }

                // Mark the node as visited, to prevent infinite loops
                visited = visited.slice(0).concat(fromNode);

                // Move to other reachable portals
                for (const next of fromNode.reachablePortals) {
                    if (visited.includes(next.node)) {
                        continue;
                    }

                    findTarget(next.node, steps + next.steps, visited);
                }
            })(startNode);*/

            // document.querySelector('.answer').innerText =
        </script>
    </body>
</html>
